## 算法
1. 刷完剑指Offer
2. 动态规划经典题目
3. 最短路径问题
4. 字符串匹配（前缀后缀树，KMP等）
5. 八大排序算法时间复杂度分析
6. 重点默写快速排序、归并排序、堆排序等
7. 树的5种遍历方式：前中后、深度优先遍历（使用栈）、广度优先遍历（也叫宽度优先遍历，和层次遍历一个意思，使用队列来实现）
8. 最小生成树、最短路径算法

## 数据结构
1. 树（平衡二叉树，2-3树，红黑树，B/B+树）
2. 图的表示（矩阵表示的题目）

## 大型网站结构和Java中间件实践
> 再温习一遍


## 项目温习总结

## 比赛总结


## Mysql

#### 索引 

1. MyISAM/InnoDB索引原理（聚集索引、非聚集索引）
2. 索引的创建方式
3. 索引的使用及分析

#### join的各种方式

1. 当A left join B时，对于联结条件来说，一个A的联结字段对应B的多条记录，则会发生1：N的情况
解决方法是让B表的联结字段唯一。

2. inner join 
> 包含两种方式，一种是隐式的，一种是显示的
- select A.id,B.name from A,B where A.id = B.id;
这句其实是先内联接两个表生成中间表，然后从中间表中过滤出where子句中限制的记录。
- select A.id,B.name from A inner join B on A.id = B.id;
返回where查询条件或者on联结条件的记录，即返回两个表满足where或者on条件的记录
换句话说就是条件里两个表之间要对应，不对应的就过滤，这也是内联接和外联结的区别

3. left join（left outer join）、right join（right outer join）、full join（full outer join）
> 这三种是外联结，outer关键字可以省略，和内联接的区别是外联接不仅返回符合条件的记录还返回没有匹配的记录，具体如下
- left join：以左表为基准，当联结条件中右表没有与左表匹配的记录则此时右表的对应字段显示为null (1:0)；
如果有一条匹配的记录则 1:1；如果有多于1条这会出现 1:n，即结果集大于左表原来的记录数
- right join和left join具有相同的效果，只是左右不一样
- full join：相当于先进行一次left join，然后在进行一次right join，然后对这两次的结果集合并，然后去重。换句话说包含三个部分
即符合联结条件的记录，以左表为基准与右表不配的记录，以右表为基准与左表不匹配的记录

注意Mysql不支持全连接，Oracle和DB2支持

4. cross join
> 有两种一种是隐式的一种是显示的
- select A.id, B.name from A,B where A.id = 1;
A表中的每一条满足where子句的记录都对应B表的全部记录
- select A.id ,B.name from A cross join B on A.id = 1;
效果和1中的一样

5. where字句是对联结之后的结果集进行过滤，即放在on联结条件子句之后

#### group by的注意事项
> http://blog.csdn.net/xxpyeippx/article/details/8059910

当使用分组时，select的字段只能是分组字段列或者聚集函数列


#### union联合的注意事项
> union用于联合两个select语句的结果集，并去除表这两个结果集中任何重复的数据记录（即A与B中重复的也删除，而不仅仅是删除A中重复，然后删除B中重复，然后联合，相当于先合并在一个临时表中，对这个临时表进行去重，即去重是在合并之后进行的）;
但是可以使用union all来允许联合两个结果集重复的数据记录

1. 两个select子句的列的数量必须相同。
2. 两个select子句的列的名称可以不相同，但是逻辑上对应的列的顺序要一致，使用的函数表达式和聚集函数也要一样，即按照列的顺序进行联合的。
3. 对应列的数据类型可以不一致，但必须是DBMS允许的隐含的类型转换类型
4. select子句中可以包含任何过滤条件 distinct、where等
5. 对于order by子句，因为两个select子句不允许使用不同的排序策略，所以多个select子句进行联合一般包含一条order by子句，而且是在最后位置
如果在select子句上使用order by子句也会被优化忽略，因为和最外层的order by子句重叠；如果想让内排序其作用则可以配合使用limit，从而使内排序对子select结果集产生影响。
6. union可以实现行变列的转换 http://blog.csdn.net/rainyspring4540/article/details/50230259

#### 触发器
> 1. 一种特殊的存储过程，由事件触发（insert,delete,update）。
分为事前触发和事后触发。而语句级触发可以在语句执行前或者后执行，行级触发发生在触发器所影响的每一行触发一次。
2. 和存储过程区别：触发器隐时调用，不能接受参数输入。

http://www.cnblogs.com/duodushu/p/5446384.html

触发器语法
```
# 指定触发器的名称
create trigger trigger_name 
# 指定触发器执行的时机（有两个值 before、after）
trigger_time          
# 指定触发器对指定数据表上的监测的事件
triggle_event on table_name 
for each row
# 指定将要执行的触发器实体内容，可以是用begin end包含的sql语句
triggle_statement;          
```


有三个语句级事件：insert、update、delete，以及两个行级事件：load data、replace
其中load data语句用于将一个文件装入到一个数据表中，相当于一系列inset操作
对于replace语句和insert很像
> 只是在表中有 primary key 或 unique 索引时，如果插入的数据和原来 primary key 或 unique 索引一致时，
会先删除原来的数据，然后增加一条新数据，也就是说，一条 REPLACE 语句有时候等价于一条。

触发器分类
```
INSERT 型触发器：插入某一行时激活触发器，可能通过 INSERT、LOAD DATA、REPLACE 语句触发；
UPDATE 型触发器：更改某一行时激活触发器，可能通过 UPDATE 语句触发；
DELETE 型触发器：删除某一行时激活触发器，可能通过 DELETE、REPLACE 语句触发。

再结合触发时机则总共可以分为6中触发器
即：BEFORE INSERT、BEFORE UPDATE、BEFORE DELETE、AFTER INSERT、AFTER UPDATE、AFTER DELETE。
```

begin ... end
> 语法为：
begin
[statement_list]
end

> statement_list 代表一个或多个语句的列表，列表内的每条语句都必须用分号（;）来结尾。
而在MySQL中，分号是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL可以开始执行了。因此，解释器遇到statement_list 中的分号后就开始执行，然后会报出错误，因为没有找到和 BEGIN 匹配的 END。

delemiter 定义定界符
> 这时就会用到 delemiter 命令（delemiter 是定界符，分隔符的意思），它是一条命令，不需要语句结束标识，语法为：
delemiter new_delemiter
new_delemiter 可以设为1个或多个长度的符号，默认的是分号（;），我们可以把它修改为其他符号，如$：
delemiter $
在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了$，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。

完整实例
```
delemiter $
create trigger tri_stuInsert after insert
on student for each row
begin
declare c int;
set c = (select stuCount from class where classID=new.classID);
update class set stuCount = c + 1 where classID = new.classID;
end$
delemiter ;
```

declare定义begig-end中的临时变量
> `DECLARE var_name[,...] type [DEFAULT value]`
对变量赋值采用 set 语句，语法为：
`set var_name = expr [,var_name = expr] ...`

new与old详解
> MySQL 中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据。
具体地：
在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；
在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；
在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；
使用方法： NEW.columnName （columnName 为相应数据表某一列名）
另外，OLD 是只读的，而 NEW 则可以在触发器中使用 SET 赋值，这样不会再次触发触发器，造成循环调用（如每插入一个学生前，都在其学号前加“2013”）。


查看触发器，和查看数据表一样
> 
`SHOW TRIGGERS [FROM schema_name];`

删除触发器，一个数据表对应对个触发器，即触发器是和数据表绑定的
> 
`DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name`


触发器的执行顺序
> 我们建立的数据库一般都是 InnoDB 数据库，其上建立的表是事务性表，也就是事务安全的。这时，若SQL语句或触发器执行失败，MySQL 会回滚事务，有：
1. 如果 BEFORE 触发器执行失败，SQL 无法正确执行。
2. SQL 执行失败时，AFTER 型触发器不会触发。
3. AFTER 类型的触发器执行失败，SQL 会回滚


#### 存储过程

特点
> 
1. 一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。
2. 优点：增加SQL语言的功能，灵活性和安全性。执行速度快，减少网络传输。缺点在于可移植性差。
3. 和函数区别：存储过程是独立的部分，而函数作为查询语句的一部分，嵌入在SQL中，执行速度更快。
4. 游标：用于定位结果集的行，一种能够从包含多条数据记录的结果集中每次提取一条记录的机制。

1-创建存储过程
> 
```
create procedure sp_name()
begin
[statement_list]
end
```

2-调用存储过程
> `call sp_name()`

3-删除存储过程
> `drop procedure sp_name;`
注意不能在一个存储过程中删除另一个存储过程。

4-查看存储过程
> 
`show procedure status;`
`show create procedure sp_name;`

5-存储过程实例
>语法以及内置函数介绍以及使用：http://www.cnblogs.com/cxxjohnson/p/5965194.html

5.1-最简单的一个存储过程
```
/********************* 创建表 *****************************/
delimiter //

DROP TABLE if exists test //
CREATE TABLE test(
  id int(11) NULL
) //

/********************** 最简单的一个存储过程 **********************/
drop procedure if exists sp//
CREATE PROCEDURE sp() //
 
call sp()//

```

5.2-带输入参数的存储过程
```
/********************* 带输入参数的存储过程  *******************/

drop procedure if exists sp1 //

create procedure sp1(in p int)
comment 'insert into a int value'
begin
  /* 定义一个整形变量 */
  declare v1 int;
  
  /* 将输入参数的值赋给变量 */
  set v1 = p;
  
  /* 执行插入操作 */
  insert into test(id) values(v1);
end
//

/* 调用这个存储过程  */
call sp1(1)//

/* 去数据库查看调用之后的结果 */
select * from test//
```

5.3-带输出参数的存储过程
```
 /****************** 带输出参数的存储过程 ************************/

drop procedure if exists sp2 //
create procedure sp2(out p int)
/*这里的DETERMINISTIC子句表示输入和输出的值都是确定的,不会再改变.我一同事说目前mysql并没有实现该功能,因此加不加都是NOT DETERMINISTIC的*/
DETERMINISTIC
begin
  select max(id) into p from test;
end
//

/* 调用该存储过程，注意：输出参数必须是一个带@符号的变量 */
call sp2(@pv)//

/* 查询刚刚在存储过程中使用到的变量 */
select @pv//                                                    
```

5.4-带输入和输出参数的存储过程 
```
/******************** 带输入和输出参数的存储过程 ***********************/

drop procedure if exists sp3 //
create procedure sp3(in p1 int , out p2 int)
begin

  if p1 = 1 then
    /* 用@符号加变量名的方式定义一个变量，与declare类似 */
    set @v = 10;
  else
    set @v = 20;
  end if;
  
  /* 语句体内可以执行多条sql，但必须以分号分隔 */
  insert into test(id) values(@v);
  select max(id) into p2 from test;
  
end
//

/* 调用该存储过程，注意：输入参数是一个值，而输出参数则必须是一个带@符号的变量 */
call sp3(1,@ret)//

select @ret//
```

5.5-既做输入又做输出参数的存储过程
```
/***************** 既做输入又做输出参数的存储过程 **************************/

drop procedure if exists sp4 //
create procedure sp4(inout p4 int)
begin
   if p4 = 4 then
      set @pg = 400;
   else
      set @pg = 500;
   end if; 
   
   select @pg;
   
end//

call sp4(@pp)//

/* 这里需要先设置一个已赋值的变量，然后再作为参数传入 */
set @pp = 4//
call sp4(@pp)//
select @pp //
```

#### 创建分区表

#### 创建视图
> 优点：重用SQL，简化数据库查询，提高数据库的**安全性和逻辑独立性**。

1. 从数据库中的基本表中选取出来的逻辑窗口，虚表，本身并不存在。将表与表之间的复杂操作和搜索条件对用户不可见，用户只需要对视图进行查询即可。但是不能提高查询效率。
减少数据库和应用程序的耦合性，即应用程序只对应视图逻辑字段，对于视图之下的真实数据表的结构改变（如增加一列等），应用程序是无感的
2. 同时由于底层数据表可能包含一些敏感的数据，但是又不想对某些程序开放这些敏感的数据，则可以在创建视图的时候忽略这些敏感字段，这样用户程序是
查询不到敏感数据的，对不同权限的查询程序创建不同的视图，可以做到权限管理

```
use test; # 创建视图和创建普通表是一样，需要指定数据库，当然也可以不指定则使用当前数据库
create view view_A_B(id,name,sex,age,department) 
as select A.id,A.name,A.sex,A.age,B.department 
from test.A A, test.B B
where A.id = B.id;
```

需要注意的是视图虽然是虚表，但是其逻辑地位和表是一样的，既不允许视图和表的重名，存在于指定数据库当中

查看视图/表结构
```
describe view_name/table_name;

# 等价于 show columns from view_name/table_name，是其简写形式
```

显示创建视图/表的SQL语句

```
show create view/table view_name/table_name;

```

修改视图结构

```
alter view view_name(id,name)
as select id,name 
from test.A;
```

更新视图中的数据

> 视图是虚拟表，本身不包含数据，而是视图会将数据更新映射到底层的数据表；
视图的数据行和底层的数据表行之间必须具有一一对应的关系时，视图才是可更改的，否则是不可更改的，具体如下：
视图中存在聚合函数，distinct、group by、union、having 、join等。
所以视图的限制是很多的，在很多情况下，视图只是用来查询数据的虚拟表，而不是要通过视图来更新数据，如果堆不可更改视图进行更新操作
很可能造成数据更新失败

删除视图

```
drop view if exists view_name;
```
#### 创建内键外键