## 算法
1. 刷完剑指Offer
2. 动态规划经典题目
3. 最短路径问题
4. 字符串匹配（前缀后缀树，KMP等）
5. 八大排序算法时间复杂度分析
6. 重点默写快速排序、归并排序、堆排序等
7. 树的5种遍历方式：前中后、深度优先遍历（使用栈）、广度优先遍历（也叫宽度优先遍历，和层次遍历一个意思，使用队列来实现）
8. 最小生成树、最短路径算法

## 数据结构
1. 树（平衡二叉树，2-3树，红黑树，B/B+树）
2. 图的表示（矩阵表示的题目）

## 大型网站结构和Java中间件实践
> 再温习一遍


## 项目温习总结

## 比赛总结


## Mysql

#### 索引 

1. MyISAM/InnoDB索引原理（聚集索引、非聚集索引）
2. 索引的创建方式
3. 索引的使用及分析

#### join的各种方式

1. 当A left join B时，对于联结条件来说，一个A的联结字段对应B的多条记录，则会发生1：N的情况
解决方法是让B表的联结字段唯一。

2. inner join 
> 包含两种方式，一种是隐式的，一种是显示的
- select A.id,B.name from A,B where A.id = B.id;
这句其实是先内联接两个表生成中间表，然后从中间表中过滤出where子句中限制的记录。
- select A.id,B.name from A inner join B on A.id = B.id;
返回where查询条件或者on联结条件的记录，即返回两个表满足where或者on条件的记录
换句话说就是条件里两个表之间要对应，不对应的就过滤，这也是内联接和外联结的区别

3. left join（left outer join）、right join（right outer join）、full join（full outer join）
> 这三种是外联结，outer关键字可以省略，和内联接的区别是外联接不仅返回符合条件的记录还返回没有匹配的记录，具体如下
- left join：以左表为基准，当联结条件中右表没有与左表匹配的记录则此时右表的对应字段显示为null (1:0)；
如果有一条匹配的记录则 1:1；如果有多于1条这会出现 1:n，即结果集大于左表原来的记录数
- right join和left join具有相同的效果，只是左右不一样
- full join：相当于先进行一次left join，然后在进行一次right join，然后对这两次的结果集合并，然后去重。换句话说包含三个部分
即符合联结条件的记录，以左表为基准与右表不配的记录，以右表为基准与左表不匹配的记录

注意Mysql不支持全连接，Oracle和DB2支持

4. cross join
> 有两种一种是隐式的一种是显示的
- select A.id, B.name from A,B where A.id = 1;
A表中的每一条满足where子句的记录都对应B表的全部记录
- select A.id ,B.name from A cross join B on A.id = 1;
效果和1中的一样

5. where字句是对联结之后的结果集进行过滤，即放在on联结条件子句之后

#### group by的注意事项
> http://blog.csdn.net/xxpyeippx/article/details/8059910

当使用分组时，select的字段只能是分组字段列或者聚集函数列


#### union联合的注意事项
> union用于联合两个select语句的结果集，并去除表这两个结果集中任何重复的数据记录（即A与B中重复的也删除，而不仅仅是删除A中重复，然后删除B中重复，然后联合，相当于先合并在一个临时表中，对这个临时表进行去重，即去重是在合并之后进行的）;
但是可以使用union all来允许联合两个结果集重复的数据记录

1. 两个select子句的列的数量必须相同。
2. 两个select子句的列的名称可以不相同，但是逻辑上对应的列的顺序要一致，使用的函数表达式和聚集函数也要一样，即按照列的顺序进行联合的。
3. 对应列的数据类型可以不一致，但必须是DBMS允许的隐含的类型转换类型
4. select子句中可以包含任何过滤条件 distinct、where等
5. 对于order by子句，因为两个select子句不允许使用不同的排序策略，所以多个select子句进行联合一般包含一条order by子句，而且是在最后位置
如果在select子句上使用order by子句也会被优化忽略，因为和最外层的order by子句重叠；如果想让内排序其作用则可以配合使用limit，从而使内排序对子select结果集产生影响。
6. union可以实现行变列的转换 http://blog.csdn.net/rainyspring4540/article/details/50230259

#### 触发器


#### 存储过程

#### 创建分区表

#### 创建视图
> 优点：重用SQL，简化数据库查询，提高数据库的**安全性和逻辑独立性**。

1. 从数据库中的基本表中选取出来的逻辑窗口，虚表，本身并不存在。将表与表之间的复杂操作和搜索条件对用户不可见，用户只需要对视图进行查询即可。但是不能提高查询效率。
减少数据库和应用程序的耦合性，即应用程序只对应视图逻辑字段，对于视图之下的真实数据表的结构改变（如增加一列等），应用程序是无感的
2. 同时由于底层数据表可能包含一些敏感的数据，但是又不想对某些程序开放这些敏感的数据，则可以在创建视图的时候忽略这些敏感字段，这样用户程序是
查询不到敏感数据的，对不同权限的查询程序创建不同的视图，可以做到权限管理

```
use test; # 创建视图和创建普通表是一样，需要指定数据库，当然也可以不指定则使用当前数据库
create view view_A_B(id,name,sex,age,department) 
as select A.id,A.name,A.sex,A.age,B.department 
from test.A A, test.B B
where A.id = B.id;
```

需要注意的是视图虽然是虚表，但是其逻辑地位和表是一样的，既不允许视图和表的重名，存在于指定数据库当中

查看视图/表结构
```
describe view_name/table_name;

# 等价于 show columns from view_name/table_name，是其简写形式
```

显示创建视图/表的SQL语句

```
show create view/table view_name/table_name;

```

修改视图结构

```
alter view view_name(id,name)
as select id,name 
from test.A;
```

更新视图中的数据

> 视图是虚拟表，本身不包含数据，而是视图会将数据更新映射到底层的数据表；
视图的数据行和底层的数据表行之间必须具有一一对应的关系时，视图才是可更改的，否则是不可更改的，具体如下：
视图中存在聚合函数，distinct、group by、union、having 、join等。
所以视图的限制是很多的，在很多情况下，视图只是用来查询数据的虚拟表，而不是要通过视图来更新数据，如果堆不可更改视图进行更新操作
很可能造成数据更新失败

删除视图

```
drop view if exists view_name;
```
#### 创建内键外键